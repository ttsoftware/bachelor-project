* Bugs
** DONE (Ulrik) The optimizer does not propagate constants to output functions.
*** TODO Test that this works now.
    

* Features
** [#A] Support for Unicode, or at least ÆØÅ!

** DONE [#B] Limit constant propagation
*** Description:
   Propagating constants seem to introduce a lot of copying in cases such as
   ``abcd|[a-z]*''. Essentially, the bit-codes for a, ab, and abc parsed using
   ``[a-z]*'' are included as constants in the "optimized" SST.  Maybe the
   static analyzer is too eager. An alternative approach could work as follows:

   When the analyzer currently encounters an assignment of the form x <- C[x]
   where C[.]  is a constant context and the value of x is statically known to
   be some `v', the static value of x is updated to C[v]. This might be too
   eager, consider the following:

   1 : x <- 1010
       y <- 1
       goto 2
   2 : x <- x y 0
       y <- 0
       if .. { write(x); accept() } else goto 3
   3 : x <- x y 1
       if .. { write(x); accept() } else goto 4
   4 : ...

   Assuming that block 1 is not reachable from block 4, this will be "optimized"
   to

   1 : goto 2
   2 : if .. { write(101010); accept() } else goto 3
   3 : if .. { write(10101001); accept() } else goto 4
   4 : ...

   We eliminated both x and y, but we have repeated the value "10101". This is
   exactly what happens for expressions of the form ``w|[a-z]*'', and will lead
   to |w| constants in the program, each a prefix of the next.

   We should try to change the static analysis such that dynamic updates are not
   eliminated, but assign-once constants are. This means that in the above
   example, the x buffer will be left intact, but the y buffer is eliminated,
   since it is only assigned once and never updated using itself as input.
*** Status:
  When optimizing at level < 3, the static analyzer will consider all variables
  depending on themselves as ambiguous.
** DONE Allow for appending of arrays of chunks.
*** Description: 
    Instead of making one function call per word appended, with a corresponding range check, 
    make one function call and iterate over an array with all the words.  Put one range check
    in the beginning.
*** Status
    Is done.
** DONE The runtime should detect if the program is byte-aligned
*** Description
    If the word size is 8 everything is always byte-aligned, and all the checks pertaining to 
    this should be removed.  Consider wrapping the key parts of crt.c in suitable #DEFINEs, so
    the generated C code will reflect this.
*** Status
    This is now handled by the more general array functions.


** TODO (kris+sebbe) Add extra language features
*** Description
    We have brainstormed how to improve Kleenex' expressive power. Our idea is the following:

    Add extra constructs to Kleenex Terms:
      term*     - repeat 0 or more times
      term+     - repeat 1 or more times
      term{...} - repeat a number of times
      term?     - repeat 0 or 1 times
      term [X]  - embed X in the generated C code, and don't output the result of term
      a@term    - output the term to a named register, all named registers are allocated
                  at compile time

    Add the following syntax for the first term:
      term1 >> term 2 >> term3 ...

      This compiles all the terms as seperate programs, and pipes the output between them.
*** Status
    WIP
